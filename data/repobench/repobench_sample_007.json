{
  "repo_name": "FoundationVision/UniRef",
  "file_path": "projects/UniRef/uniref/models/deformable_detr/matcher.py",
  "context": [
    {
      "identifier": "box_cxcywh_to_xyxy",
      "path": "projects/UniRef/uniref/util/box_ops.py",
      "snippet": "def box_cxcywh_to_xyxy(x):\n    # print('box:\\n', x)\n\n    x_c, y_c, w, h = x.unbind(-1)\n    b = [(x_c - 0.5 * w), (y_c - 0.5 * h),\n         (x_c + 0.5 * w), (y_c + 0.5 * h)]\n    return torch.stack(b, dim=-1)"
    },
    {
      "identifier": "generalized_box_iou",
      "path": "projects/UniRef/uniref/util/box_ops.py",
      "snippet": "def generalized_box_iou(boxes1, boxes2):\n    \"\"\"\n    Generalized IoU from https://giou.stanford.edu/\n\n    The boxes should be in [x0, y0, x1, y1] format\n\n    Returns a [N, M] pairwise matrix, where N = len(boxes1)\n    and M = len(boxes2)\n    \"\"\"\n    # degenerate boxes gives inf / nan results\n    # so do an early check\n\n    assert (boxes1[:, 2:] >= boxes1[:, :2]).all()\n    assert (boxes2[:, 2:] >= boxes2[:, :2]).all()\n    iou, union = box_iou(boxes1, boxes2)\n\n    lt = torch.min(boxes1[:, None, :2], boxes2[:, :2])\n    rb = torch.max(boxes1[:, None, 2:], boxes2[:, 2:])\n\n    wh = (rb - lt).clamp(min=0)  # [N,M,2]\n    area = wh[:, :, 0] * wh[:, :, 1]\n\n    return iou - (area - union) / (area+1e-7)"
    }
  ],
  "import_statement": "import torch\nimport torch.nn.functional as F\nimport torchvision.ops as ops\nfrom scipy.optimize import linear_sum_assignment\nfrom torch import nn\nfrom ...util.box_ops import box_cxcywh_to_xyxy, generalized_box_iou",
  "token_num": 1206,
  "cropped_code": "# ------------------------------------------------------------------------\n# Deformable DETR\n# Copyright (c) 2020 SenseTime. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Modified from DETR (https://github.com/facebookresearch/detr)\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n# ------------------------------------------------------------------------\n\n\"\"\"\nModules to compute the matching cost and solve the corresponding LSAP.\n\"\"\"\n\n\nclass HungarianMatcher(nn.Module):\n    \"\"\"This class computes an assignment between the targets and the predictions of the network\n\n    For efficiency reasons, the targets don't include the no_object. Because of this, in general,\n    there are more predictions than targets. In this case, we do a 1-to-1 matching of the best predictions,\n    while the others are un-matched (and thus treated as non-objects).\n    \"\"\"\n\n    def __init__(self,\n                 cost_class: float = 1,\n                 cost_bbox: float = 1,\n                 cost_giou: float = 1):\n        \"\"\"Creates the matcher\n\n        Params:\n            cost_class: This is the relative weight of the classification error in the matching cost\n            cost_bbox: This is the relative weight of the L1 error of the bounding box coordinates in the matching cost\n            cost_giou: This is the relative weight of the giou loss of the bounding box in the matching cost\n        \"\"\"\n        super().__init__()\n        self.cost_class = cost_class\n        self.cost_bbox = cost_bbox\n        self.cost_giou = cost_giou\n        assert cost_class != 0 or cost_bbox != 0 or cost_giou != 0, \"all costs cant be 0\"\n        \n    def forward_ota(self, outputs, targets):\n        \"\"\" simOTA for detr\n        \"\"\"\n        with torch.no_grad():\n            bs, num_queries = outputs[\"pred_logits\"].shape[:2]\n            out_prob = outputs[\"pred_logits\"].sigmoid()\n            out_bbox = outputs[\"pred_boxes\"]  # \u8df3\u8fc7frame \u7ef4\u5ea6\n            indices = []\n            matched_ids = []\n            for batch_idx in range(bs):\n                bz_boxes = out_bbox[batch_idx] #[300,4]\n                bz_out_prob = out_prob[batch_idx] \n                bz_tgt_ids = targets[batch_idx][\"labels\"]\n                num_insts = len(bz_tgt_ids)\n                bz_gtboxs = targets[batch_idx]['boxes'].reshape(num_insts,4) #[num_gt, 4]\n                fg_mask, is_in_boxes_and_center  = \\\n                    self.get_in_boxes_info(bz_boxes,bz_gtboxs,expanded_strides=32)\n                pair_wise_ious = ops.box_iou(box_cxcywh_to_xyxy(bz_boxes), box_cxcywh_to_xyxy(bz_gtboxs))\n                # pair_wise_ious_loss = -torch.log(pair_wise_ious + 1e-8)\n\n                # Compute the classification cost.\n                alpha = 0.25\n                gamma = 2.0\n                neg_cost_class = (1 - alpha) * (bz_out_prob ** gamma) * (-(1 - bz_out_prob + 1e-8).log())\n                pos_cost_class = alpha * ((1 - bz_out_prob) ** gamma) * (-(bz_out_prob + 1e-8).log())\n                cost_class = pos_cost_class[:, bz_tgt_ids] - neg_cost_class[:, bz_tgt_ids]\n",
  "all_code": "# ------------------------------------------------------------------------\n# Deformable DETR\n# Copyright (c) 2020 SenseTime. All Rights Reserved.\n# Licensed under the Apache License, Version 2.0 [see LICENSE for details]\n# ------------------------------------------------------------------------\n# Modified from DETR (https://github.com/facebookresearch/detr)\n# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n# ------------------------------------------------------------------------\n\n\"\"\"\nModules to compute the matching cost and solve the corresponding LSAP.\n\"\"\"\n\n\nclass HungarianMatcher(nn.Module):\n    \"\"\"This class computes an assignment between the targets and the predictions of the network\n\n    For efficiency reasons, the targets don't include the no_object. Because of this, in general,\n    there are more predictions than targets. In this case, we do a 1-to-1 matching of the best predictions,\n    while the others are un-matched (and thus treated as non-objects).\n    \"\"\"\n\n    def __init__(self,\n                 cost_class: float = 1,\n                 cost_bbox: float = 1,\n                 cost_giou: float = 1):\n        \"\"\"Creates the matcher\n\n        Params:\n            cost_class: This is the relative weight of the classification error in the matching cost\n            cost_bbox: This is the relative weight of the L1 error of the bounding box coordinates in the matching cost\n            cost_giou: This is the relative weight of the giou loss of the bounding box in the matching cost\n        \"\"\"\n        super().__init__()\n        self.cost_class = cost_class\n        self.cost_bbox = cost_bbox\n        self.cost_giou = cost_giou\n        assert cost_class != 0 or cost_bbox != 0 or cost_giou != 0, \"all costs cant be 0\"\n        \n    def forward_ota(self, outputs, targets):\n        \"\"\" simOTA for detr\n        \"\"\"\n        with torch.no_grad():\n            bs, num_queries = outputs[\"pred_logits\"].shape[:2]\n            out_prob = outputs[\"pred_logits\"].sigmoid()\n            out_bbox = outputs[\"pred_boxes\"]  # \u8df3\u8fc7frame \u7ef4\u5ea6\n            indices = []\n            matched_ids = []\n            for batch_idx in range(bs):\n                bz_boxes = out_bbox[batch_idx] #[300,4]\n                bz_out_prob = out_prob[batch_idx] \n                bz_tgt_ids = targets[batch_idx][\"labels\"]\n                num_insts = len(bz_tgt_ids)\n                bz_gtboxs = targets[batch_idx]['boxes'].reshape(num_insts,4) #[num_gt, 4]\n                fg_mask, is_in_boxes_and_center  = \\\n                    self.get_in_boxes_info(bz_boxes,bz_gtboxs,expanded_strides=32)\n                pair_wise_ious = ops.box_iou(box_cxcywh_to_xyxy(bz_boxes), box_cxcywh_to_xyxy(bz_gtboxs))\n                # pair_wise_ious_loss = -torch.log(pair_wise_ious + 1e-8)\n\n                # Compute the classification cost.\n                alpha = 0.25\n                gamma = 2.0\n                neg_cost_class = (1 - alpha) * (bz_out_prob ** gamma) * (-(1 - bz_out_prob + 1e-8).log())\n                pos_cost_class = alpha * ((1 - bz_out_prob) ** gamma) * (-(bz_out_prob + 1e-8).log())\n                cost_class = pos_cost_class[:, bz_tgt_ids] - neg_cost_class[:, bz_tgt_ids]",
  "next_line": "                cost_giou = -generalized_box_iou(box_cxcywh_to_xyxy(bz_boxes),  box_cxcywh_to_xyxy(bz_gtboxs))",
  "gold_snippet_index": 1,
  "created_at": "2023-12-22 13:31:33+00:00",
  "level": "2k"
}